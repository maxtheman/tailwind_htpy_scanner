import ast
from pathlib import Path
from typing import Set, List, Optional

class TemplateVisitor(ast.NodeVisitor):
    """AST visitor that extracts class names from HTPy template code."""
    def __init__(self):
        self.classes: Set[str] = set()

    def visit_Call(self, node: ast.Call) -> None:
        """Visit function calls, looking for class_ attributes."""

        if hasattr(node, 'keywords'):
            for keyword in node.keywords:
                if keyword.arg == 'class_' and isinstance(keyword.value, ast.Constant):
                    classes = keyword.value.value.split()
                    self.classes.update(classes)


        if (isinstance(node.func, ast.Attribute) and
            node.args and
            isinstance(node.args[0], ast.Constant) and
            isinstance(node.args[0].value, str) and
            node.args[0].value.startswith('.')):
            classes = node.args[0].value[1:].split()
            self.classes.update(classes)

        self.generic_visit(node)

def scan_file(file_path: Path) -> Set[str]:
    """Scan a single Python file for HTPy class definitions."""
    with open(file_path) as f:
        try:
            tree = ast.parse(f.read())
            visitor = TemplateVisitor()
            visitor.visit(tree)
            return visitor.classes
        except SyntaxError:
            print(f"Error parsing {file_path}")
            return set()

def scan_directory(directory: Path, template_files: Optional[List[str]] = None) -> Set[str]:
    """Scan directory for Python files containing HTPy templates."""
    all_classes = set()

    if template_files:
        for file_name in template_files:
            file_path = directory / file_name
            if file_path.exists():
                print(f"Scanning {file_path}")
                classes = scan_file(file_path)
                all_classes.update(classes)
    else:
        for file_path in directory.rglob("*.py"):
            if not any(part.startswith('.') for part in file_path.parts):
                print(f"Scanning {file_path}")
                classes = scan_file(file_path)
                all_classes.update(classes)

    return all_classes

def generate_template_js(classes: Set[str], output_path: Path) -> None:
    """Generate a JavaScript file containing template classes for Tailwind."""
    js_content = f"""// Generated by template scanner - do not edit directly
const templates = `
{' '.join(sorted(classes))}
`;

export default templates;
"""
    output_path.write_text(js_content)
    print(f"Found classes: {', '.join(sorted(classes))}")

def main(base_dir: Path, template_files: List[str], watch: bool = False):
    """Main function to scan templates and generate JS file."""
    if base_dir is None:
        base_dir = Path(__file__).parent.parent  # Go up one directory from scripts

    output_dir = base_dir / "frontend" / "src"
    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / "templates.js"

    def scan_and_generate():
        print(f"Scanning directory: {base_dir}")
        print(f"Template files: {template_files}")
        classes = scan_directory(base_dir, template_files)
        generate_template_js(classes, output_file)
        print(f"Generated {output_file} with {len(classes)} unique classes")

    scan_and_generate()

    if watch:
        import time
        from watchdog.observers import Observer
        from watchdog.events import FileSystemEventHandler

        class TemplateHandler(FileSystemEventHandler):
            def on_modified(self, event):
                if event.src_path.endswith('.py'): #type: ignore
                    print(f"Detected change in {event.src_path}")
                    scan_and_generate()

        observer = Observer()
        observer.schedule(TemplateHandler(), str(base_dir), recursive=True)
        observer.start()

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
            observer.join()

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Scan HTPy templates for Tailwind classes")
    parser.add_argument('--dir', type=Path, help='Base directory to scan')
    parser.add_argument('--files', nargs='+', help='Specific template files to scan')
    parser.add_argument('--watch', action='store_true', help='Watch for file changes')

    args = parser.parse_args()

    main(args.dir, args.files, args.watch)
